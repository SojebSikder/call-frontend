<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Video Call</title>
    <style>
        video {
            width: 300px;
            height: 225px;
            margin: 10px;
            background: #000;
        }
    </style>
</head>

<body>
    <h2>WebRTC Video Call</h2>
    <input type="text" id="username" placeholder="Enter your username" />
    <button onclick="join()">Join</button>
    <br><br>
    <input type="text" id="callTo" placeholder="Call username" />
    <button onclick="callUser()">Call</button>
    <br><br>
    <button onclick="endCall()">End Call</button>
    <br><br>
    <div id="videoContainer">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.4.1/socket.io.js"></script>
    <script>
        const socket = io("http://localhost:4000", {
            auth: {
                token: "jwt_token"
            }
        });

        let localStream, peerConnection;
        const config = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' },
            ]
        };
        let iceCandidatesQueue = [];

        function join() {
            const username = document.getElementById("username").value;
            socket.emit("join", { username });
        }

        async function setupPeerConnection(remoteUsername) {
            peerConnection = new RTCPeerConnection(config);

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    socket.emit("iceCandidate", {
                        receiver: remoteUsername,
                        candidate: event.candidate
                    });
                }
            };

            peerConnection.ontrack = event => {
                const remoteVideo = document.getElementById("remoteVideo");
                remoteVideo.srcObject = event.streams[0];
            };

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
                localStream.getTracks().forEach(track =>
                    peerConnection.addTrack(track, localStream)
                );

                const localVideo = document.getElementById("localVideo");
                localVideo.srcObject = localStream;
            } catch (err) {
                console.error("Error accessing media devices:", err);
            }

            return peerConnection;
        }

        async function callUser() {
            try {
                const callTo = document.getElementById("callTo").value;
                await setupPeerConnection(callTo);

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                socket.emit("call", {
                    caller: document.getElementById("username").value,
                    receiver: callTo,
                    offer
                });
            } catch (err) {
                console.error("Error making call:", err);
            }
        }

        socket.on("incomingCall", async ({ caller, offer }) => {
            try {
                await setupPeerConnection(caller);
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                // Process any queued candidates
                while (iceCandidatesQueue.length) {
                    const candidate = iceCandidatesQueue.shift();
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                socket.emit("answer", {
                    caller,
                    receiver: document.getElementById("username").value,
                    answer
                });
            } catch (err) {
                console.error("Error handling incoming call:", err);
            }
        });

        socket.on("callAccepted", async ({ answer }) => {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));

                // Process any queued candidates
                while (iceCandidatesQueue.length) {
                    const candidate = iceCandidatesQueue.shift();
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
            } catch (err) {
                console.error("Error handling accepted call:", err);
            }
        });

        socket.on("iceCandidate", async ({ candidate }) => {
            try {
                if (peerConnection && peerConnection.remoteDescription) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                } else {
                    iceCandidatesQueue.push(candidate);
                }
            } catch (err) {
                console.error("Error adding ICE candidate:", err);
            }
        });

        socket.on("callEnded", () => {
            cleanupCall();
        });

        function endCall() {
            socket.emit("endCall", { receiver: document.getElementById("callTo").value });
            cleanupCall();
        }

        function cleanupCall() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            const videoElements = document.querySelectorAll("video");
            videoElements.forEach(video => {
                video.srcObject = null;
            });
        }
    </script>
</body>

</html>
